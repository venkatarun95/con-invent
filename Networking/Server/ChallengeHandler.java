import java.util.ArrayList;
import java.util.Iterator;

class Challenge{
	private String challenger;
	private String challenged;
	
	private String challengerBoard;
	private String challengedBoard;
	
	private int resultFromChallenger; //records whether or not challenger claims to have won (1 for yes, -1 for no, 2 for draw, 0 for not yet received)
	private int resultFromChallenged; //records whether or not challenged claims to have won
	
	public enum CHALLENGE_STATUS {CHALLENGE_PROPOSED, CHALLENGE_PROCESSING, 
		CHALLENGE_ACCEPTED, CHALLENGE_REJECTED, CHALLENGE_RUNNING,
		CHALLENGE_RETIRED_SUCCESSFULLY, CHALLENGE_RETIRED_UNSUCCESSFULLY, 
		CHALLENGE_UNKNOWN_ACTIVE_STATUS, CHALLENGE_UNKNOWN_RETIRED_STATUS};
	CHALLENGE_STATUS challengeStatus;
	//note: unknown status is used when reading from stored file and status is not recorded
	
	//Variables used by GarbageCollector
	private int timestamp; //handled by GarbageCollector to see when was the last time it was edited
	private CHALLENGE_STATUS prevStatus;
	
	public Challenge(String aChallenger, String aChallenged, String aChallengerBoard){
		challenger = aChallenger;
		challenged = aChallenged;
		challengerBoard = aChallengerBoard;
		challengedBoard = null;
		challengeStatus = CHALLENGE_STATUS.CHALLENGE_PROPOSED;
		resultFromChallenger = resultFromChallenged = 0;
		
		timestamp = -1;
		prevStatus = challengeStatus;
	}

	/***Initializes a class using a string generated by Challenge:convertToString
	 * 
	 * @param str - the string from which to create the data
	 * @param retired - whether or not the challenge is retired***/
	public Challenge(String str, boolean retired){
		//Format: challenger+":"+challenged+";"+challengerBoard+":"+challengedBoard;
		int index = 0;
		while(str.charAt(index) != ':')++index;
		challenger = str.substring(0, index);
		int prevIndex = ++index;
		while(str.charAt(index) != ';')++index;
		challenged = str.substring(prevIndex, index);
		prevIndex = ++index;
		while(str.charAt(index) != ':')++index;
		challengerBoard = str.substring(prevIndex, index);
		prevIndex = ++index;
		while(index < str.length() && str.charAt(index) != ':')++index;
		challengedBoard = str.substring(prevIndex, index);

		if(index < str.length()){
			resultFromChallenger = Integer.parseInt(str.substring(index+1));
			resultFromChallenged = (resultFromChallenger == 2)?2:(-resultFromChallenger);
		}
		else{
			resultFromChallenger = resultFromChallenged = 0;
			//System.out.println("Challenge:Challenge :- " + str.charAt(index-3));
		}

		if(retired)
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_UNKNOWN_RETIRED_STATUS;
		else
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_UNKNOWN_ACTIVE_STATUS;
		timestamp = -1;
		prevStatus = challengeStatus;
		System.out.println("Challenge:Challenge :- "+resultFromChallenger+" "+challenger+":"+challenged+";"+challengerBoard+":"+challengedBoard);
	}
	
	public synchronized String getChallengedUser(){return challenged;}
	public synchronized String getChallenger(){return challenger;}
	
	public synchronized void setChallengedBoard(String board){
		challengedBoard = board;
	}

	/***Returns ratio of number of cells used by challenger to those used by the challenged. 
	 *
	 * used by 'reportResultToScoreboard' to decide the weightage of a 
	 * particular match. The value (or its multiplicative inverse) is 
	 * sent to the 'Scoreboard' class.***/
	private double getChallengerToChallengedWeightage(){
		int noChallenger = 0, noChallenged = 0;
		for(int i = 0;i < challenger.length(); i++){
			if((((byte)challenger.charAt(i))&2) != 0)
				noChallenger++;
		}
		for(int i = 0;i < challenged.length();i++){
			if((((byte)challenged.charAt(i))&2) != 0){
				noChallenged++;
			}
		}
		if(noChallenger == 0 || noChallenged == 0){
			System.err.println("Error: ChallengeHandler:Challenge:getChallengerToChallengedWeightage :- One (or both)of the two users has no active cells. A divide-by-zero error was narrowly avoided");
			return 1;
		}
		return ((double)noChallenger)/noChallenged;
	}
	
	/***Calls relevant scoreboard functions to report the result.
	 *
	 * used by reportResultFomrChallenger, reportResultFromChallenges
	 * and by SaveStatus to load scores from file***/
	public void reportResultToScoreboard(Scoreboard scoreboard){
		String winner, loser;
		boolean draw;
		double weightage = getChallengerToChallengedWeightage();
		if(resultFromChallenger == 1){
			winner = challenger;
			loser = challenged;
			draw = false;
			weightage = 1/weightage; //WARNING: Floating point imprecision
		}
		else if(resultFromChallenger == -1){
			winner = challenged;
			loser = challenger;
			draw = false;
		}
		else if(resultFromChallenger == 2){
			winner = challenger; //here winner/loser doesn't matter
			loser = challenged;
			draw = true;
		}
		else{
			System.err.println("ChallengeHandler:reportResultToScoreBoard :- Called on illegal state: ("+resultFromChallenger+", "+resultFromChallenged+")");
			return;
		}
		
		int statCode = scoreboard.reportMatchResult(winner, loser, draw, weightage);
		if(statCode == 1){
			System.err.println("ChallengeHandler:reportResultToScoreBoard :- One (or both) of winner/loser not found or both are same.");
		}
	}
	
	/***Used for reporting what challenger said about match's result
	 * If it disagrees with the challenged, it returns false. 
	 * It also sets state to RETIRED (successfully or otherwise)***/
	public synchronized boolean reportResultFromChallenger(int result, GlobalData globalData){
		resultFromChallenger = result;
		if(resultFromChallenger == resultFromChallenged && resultFromChallenger != 2){ //check if they disagree
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_RETIRED_UNSUCCESSFULLY;
			return false;
		}
		if(resultFromChallenged != 0){ //challenged has also reported
			//Report the results to update scores
			reportResultToScoreboard(globalData.scoreboard);
			
			//update the challengeStatus accordingly
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_RETIRED_SUCCESSFULLY;
		}
		return true;
	}
	
	/***Used for reporting what challenged said about match's result
	 * If it disagrees with the challenger, it returns false. 
	 * It also sets state to RETIRED (successfully or otherwise)***/
	public synchronized boolean reportResultFromChallenged(int result, GlobalData globalData){
		resultFromChallenged = result;
		if(resultFromChallenger == resultFromChallenged){ //ie. they disagree
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_RETIRED_UNSUCCESSFULLY;
			return false;
		}
		if(resultFromChallenger != 0){//challenger has also reported
			//Report the results to update scores
			reportResultToScoreboard(globalData.scoreboard);
			
			//update the challengeStatus accordingly
			challengeStatus = CHALLENGE_STATUS.CHALLENGE_RETIRED_SUCCESSFULLY;
		}
		return true;
	}
	
	/***For storage/transmission***/
	public synchronized  String convertToString(){
		String res = challenger+":"+challenged+";"+challengerBoard+":"+challengedBoard;
		if(!isActive()){
			res += ":"+resultFromChallenger;
		}
		else{
			System.out.println("ChallengeHandler:Challenge:convertToString :- Warning: Saving an active challenge. Result will not be included in saved string.");
		}
		//System.out.println("SaveStatus:convertToStringWithResult :- "+res);
		return res;
	}
	
	public synchronized void setChallengeState(CHALLENGE_STATUS status){
		challengeStatus = status;
	}
	
	public synchronized CHALLENGE_STATUS getChallengeState(){
		return challengeStatus;
	}
	
	/***Returns whether or not challenge is retired***/
	public synchronized boolean isActive(){
		if(challengeStatus == CHALLENGE_STATUS.CHALLENGE_RETIRED_SUCCESSFULLY || challengeStatus == CHALLENGE_STATUS.CHALLENGE_RETIRED_UNSUCCESSFULLY || challengeStatus == CHALLENGE_STATUS.CHALLENGE_UNKNOWN_RETIRED_STATUS)
			return false;
		return true;
	}
	
	public synchronized int getTimestamp(){return timestamp;}
	public synchronized CHALLENGE_STATUS getPrevState(){return prevStatus;}
	public synchronized void setTimestamp(int aTimestamp){timestamp = aTimestamp;}
	public synchronized void setPrevState(CHALLENGE_STATUS aPrevStatus){prevStatus = aPrevStatus;}
}

public class ChallengeHandler{

/***Handles challenges and communication between clients about them

 * Methodology: <code>challenge</code> is called whenever a challenge is to be 
 *  made. It stores the challenge in 'challenges' and exits. Each client 
 *  periodically makes a communication to check for challenges. Then the
 * 	acceptance of challenges is processed.***/

	//NOTE: An efficient datastructure must be used instead of this
	private ArrayList<Challenge> activeChallenges; //contains objects of type <code>Challenge</code>
	private ArrayList<Challenge> retiredChallenges;
	
	private GlobalData globalData;
	
	public ChallengeHandler(GlobalData aGlobalData){
		activeChallenges = new ArrayList<Challenge>();
		retiredChallenges = new ArrayList<Challenge>();
		
		globalData = aGlobalData;
	}

	/***Takes pre-existing lists of challenge data and initializes the object. 
	 * Used by SaveStatus to construct from data stored in a file.***/
	public ChallengeHandler(ArrayList<Challenge> aActiveChallenges, ArrayList<Challenge> aRetiredChallenges, GlobalData aGlobalData){
		activeChallenges = aActiveChallenges;
		retiredChallenges = aRetiredChallenges;

		globalData = aGlobalData;
	}
	
	/***Used to challenge other people. Returns a status code
	 *
	 *Status code convention:
	 * 0. Challenge registered 1. Requested user is offline 2. User has already been challenged 
	 * 3. Cannot challenge self! 4. Challenger has already challenged somebody. Please wait***/
	public synchronized int challenge(String challenged, String challenger, String board){
		//see if challenged user exists
		if(challenger.equals(challenged))return 3;
		ArrayList users = CentralServer.getClientServerList();
		Iterator iter = users.iterator();
		int status = 1;
		if(iter == null)return 1;
		//this user has a pending challenge
		if(checkForActiveChallengesByChallenger(challenger) != null || checkForActiveChallengesByChallenged(challenger) != null){
			return 4;
		}
		//challenged user has a challenge pending
		if(checkForActiveChallengesByChallenger(challenged) != null || checkForActiveChallengesByChallenged(challenged) != null){ 
			return 2;
		}
		while(iter.hasNext()){
			ClientServer server = (ClientServer)iter.next();
			if(server.getUsername().equals(challenged)){ //ie. user is online
				//Check if challenged user has already been challenged by someone
				activeChallenges.add(new Challenge(challenger, challenged, board));
				status = 0;
				break;
			}
		}
		return status;
	}
	
	/***Used for accepting a challenge.
	 *
	 * Returns an error code: 0. Successful 1. Challenge not found 2. Challenge not in state to be accepted 
	 * 3. incorrect string 'challenge'***/
	public synchronized int acceptChallenge(String acceptor, String challenge){
		Challenge ch = checkForActiveChallengesByChallenged(acceptor);
		if(ch == null)return 1;
		if(ch.getChallengeState() == Challenge.CHALLENGE_STATUS.CHALLENGE_PROCESSING){
			//upgrade state
			ch.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_ACCEPTED);

			//Process 'challenge string'
			int i;
			for(i = 0;i < challenge.length() && challenge.charAt(i)!=':';i++);
			if(challenge.charAt(i) != ':')return 3; //incorrect string. Does not have a semicolon
			if(!ch.getChallenger().equals(challenge.substring(0,i)))
				return 1; //this is not the challenge we are looking for
			
			//set the 'challeged''s board
			ch.setChallengedBoard(challenge.substring(i+1));
			return 0;
		}
		return 2;
	}
	
	/***Used for rejecting a challenge.
	 *
	 *	Returns an error code: 0. Successful 1. Challenge not found 2. Challenge not in state to be rejected***/
	public synchronized int rejectChallenge(String acceptor, String challenger){
		Challenge ch = checkForActiveChallengesByChallenged(acceptor);
		if(ch == null)return 1;
		if(ch.getChallengeState() == Challenge.CHALLENGE_STATUS.CHALLENGE_PROCESSING){
			ch.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_REJECTED);
			//activeChallenges.remove(ch);
			//retiredChallenges.add(ch);
			return 0;
		} 
		return 2;
	}
	
	/***Used for reporting the result of a challenge
	 * 
	 * Returns an error code:
	 * 0. Successful 1. Challenge not found 2. The other user disagrees***/
	public synchronized int reportResult(String reporter, int result){
		Challenge ch; //the challenge to report. Needs to be found
		boolean status;
		//search for challenge
		if((ch = checkForActiveChallengesByChallenger(reporter)) != null)
			status = ch.reportResultFromChallenger(result, globalData); 
		else if((ch = checkForActiveChallengesByChallenged(reporter)) != null)
			status = ch.reportResultFromChallenged(result, globalData);
		else
			return 1;
		
		if(!ch.isActive()){ //if it is retired due to successful reporting or otherwise, reflect the change
			activeChallenges.remove(ch);
			retiredChallenges.add(ch);
		}
		if(!status){ //the other user disagrees
			return 2;
		}
		return 0; //success
	}
	
	/***Checks whether or not a given user has been challenged. 
	 * If remove is true, the particular challenge is removed from list***/
	public synchronized Challenge checkForActiveChallengesByChallenged(String user){
		Iterator iter = activeChallenges.iterator();
		if(iter == null)return null;
		while(iter.hasNext()){
			Challenge next = (Challenge)iter.next();
			if(user.equals(next.getChallengedUser())){
				//if(next.isActive()) check no longer required as active and inactive challenges are stored separately
					return next;
			}
		}
		return null; //not found
	}
	
	/***Checks whether or not a given user has challenged somebody. 
	 * If remove is true, the particular challenge is removed from list***/
	public synchronized Challenge checkForActiveChallengesByChallenger(String user){
		Iterator iter = activeChallenges.iterator();
		if(iter == null)return null;
		while(iter.hasNext()){
			Challenge next = (Challenge)iter.next();
			if(user.equals(next.getChallenger())){
				//if(next.isActive()) check no longer required as active and inactive challenges are stored separately
					return next;
			}
		}
		return null; //not found
	}
	
	/***Removes a challenge from 'user' from list and addsit to retiredChallenges. Used in terminating/rejecting
	 *  challenges during timeout as well as connection drop with user.
	 *
	 *	Returns an error code: 0. Successful 1. Already accepted 2. Not found***/
	 
	public synchronized int removeActiveChallengeByChallenger(String challenger, boolean success){
		Iterator iter = activeChallenges.iterator();
		if(iter == null)return 2;
		while(iter.hasNext()){
			Challenge next = (Challenge)iter.next();
			if(challenger.equals(next.getChallenger())){
				if(next.getChallengeState() != Challenge.CHALLENGE_STATUS.CHALLENGE_PROPOSED && next.getChallengeState() != Challenge.CHALLENGE_STATUS.CHALLENGE_PROCESSING){
					return 1;
				}
				if(success)
					next.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_RETIRED_SUCCESSFULLY);
				else
					next.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_RETIRED_UNSUCCESSFULLY);
				activeChallenges.remove(next);
				retiredChallenges.add(next);
				return 0;
			}
		}
		return 2;
	}
	
	/***Retires an active challenge by the challenge object. Used in retiring a
	 * challenge after it has been rejected and the message has been communicated***/
	public synchronized void retireActiveChallengeByChallenge(Challenge ch){
		if(!activeChallenges.contains(ch))
			System.err.println("Error: ChallengeHandler:retireActiveChallengesByChallenge :- Challenge to remove not found.");
		activeChallenges.remove(ch);
		retiredChallenges.add(ch);
	}
	
	/***Retires an active challenge by index. Used by garbage collector
	 *
	 * @param index - the index of the challenge in activeChallenges (ArrayList) (see getNoActiveChallenges() and getChallenge(int i))
	 * @param successful - whether it was successfully terminated. Used to decide the state in which to set it
	***/
	public synchronized void retireActiveChallengeByIndex(int index, boolean successful){
		Challenge ch = activeChallenges.get(index);
		if(successful)
			ch.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_RETIRED_SUCCESSFULLY);
		else
			ch.setChallengeState(Challenge.CHALLENGE_STATUS.CHALLENGE_RETIRED_UNSUCCESSFULLY);
		retiredChallenges.add(ch);
		activeChallenges.remove(index);
	}
	
	//called and used by GarbageCollector and saveStatus
	public synchronized int getNoActiveChallenges(){
		return activeChallenges.size();
	}
	public synchronized Challenge getActiveChallenge(int i){
		return activeChallenges.get(i); //Warning: Optimization issues: Not very efficient
	}

	//called and used by saveStatus
	public synchronized int getNoRetiredChallenges(){
		return retiredChallenges.size();
	}
	public synchronized Challenge getRetiredChallenge(int i){
		return retiredChallenges.get(i); //Warning: Optimization issues: Not very efficient
	}
}
